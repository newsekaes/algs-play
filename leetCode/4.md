# LeetCode#4-寻找两个正序数组的中位数
## 1. 问题
给定两个大小为**m**和**n**的正序（从小到大）数组**nums1**和**nums2**。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为**O(log(m + n))**。

你可以假设**nums1**和**nums2**不会同时为空。
## 2. 思路
### 1. 二分法
#### 分析：
##### 1. 关于中位数的性质

1. 中位数可以作为一个分隔符，中位数**左**侧的数永远**小于等于**中位数，**右**侧的数永远**大于等于**中位数
2. 中位数分割开的两组数长度相同：  
如果数组A长度为奇数n，则中位数为第`(n + 1) / 2`个数，左右两侧各有 `(n - 1) / 2`个数  
如果数组B长度为偶数m, 则中位数为第`m / 2`个和第`m / 2 + 1`个数的平均数，刚好把偶数数组平分；为了将奇数情况和偶数情况统一， 偶数情况同样可以用对`(m + 1) / 2`**取整**来表示， 即：取整型的`(m + 1) / 2`和`(m + 1) / 2 + 1`的平均数

##### 2. 两个正序数组的中位数

根据中位数的性质，则在数组A和数组B的**合并有序数组AB**(长度为`n + m`)中，同样存在一个位置为第`(n + m + 1) / 2`（**取整**）个的中位数（偶数情况还要加上后面一个取平均值），将**AB**均分为**相同长度的两部分**  
即：  
1. 存在一个位置`i`在`[0, n]`的区间内，将数组**A**一分为二：`A_LEFT`和`A_RIGHT`
2. 同样存在一个位置`j`在`[0, m]`的区间内，将数组**B**一分为二: `B_LEFT`和`B_RIGHT`
3. `A_LEFT`和`B_LEFT`组成**AB**的左侧部分`AB_LEFT`; `A_RIGHT`和`B_RIGHT`组成**AB**的右侧部分`AB_RIGHT`。此时`AB_LEFT`和`AB_RIGHT`长度相同，并且`AB_LEFT`均**小于等于**`AB_RIGHT`
4. `i`和`j`满足`i + j = (n + m + 1) / 2 取整` 

##### 3. `i`和`j`周围大小关系
为了方便，我们将`A[i - 1]`作为**分隔符****左侧**的数，`A[i]`作为**右侧**的位置；`B[j - 1]`和`B[j]`同理. 特殊情况下，分隔符的位置可能在数组**首部或尾部**，此时视`A[-1]`或`B[-1]`为`负无穷`，视`A[n]`或`B[m]`为`正无穷`  
由 `AB_LEFT`均**小于等于**`AB_RIGHT` 这个条件可知：`A[i - 1] <= B[i]`且`B[j - 1] <= A[i]`
> 实际上， `A[i - 1] <= B[i]`和`B[j - 1] <= A[i]`满足条件之一，另一个条件自然满足：  
> 如果分隔符`i`刚好让`A[i - 1] <= B[i]`, 则将分隔符后移至`i' = i + 1`时，`j' = j - 1`, 必无法满足`A[i' - 1 ] <= B[j']`, 代入即`A[i] >= B[j - 1]`.  
> 反之亦然 

##### 4. 二分
在以上结论的基础上，我们可以用**二分法**的方法，在[0, n]上寻找`i`, `i`找到之后，`j`的位置也随之求出，中位数也可以算得

#### 代码：
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    // 边界情况下，转化为无穷
    function u2i(number, isNegtive) {
        return number === undefined ? (isNegtive ? -Infinity : Infinity) : number
    }
    if (nums1.length > nums2.length) {
        return findMedianSortedArrays(nums2, nums1)
    }
    let n = nums1.length, m = nums2.length, left = 0, right = n
    let mi1, mi2
    while (left <= right) {
        const i = parseInt((left + right + 1) / 2)
        const j = parseInt((m + n + 1) / 2) - i
        if (u2i(nums1[i - 1], true) <= u2i(nums2[j])) {
            left = i + 1
            mi1 = i
            mi2 = j
        } else {
            right = i - 1
        }
    }
    const median1 = Math.max(u2i(nums1[mi1 - 1], true), u2i(nums2[mi2 - 1], true))
    const median2 = Math.min(u2i(nums1[mi1]), u2i(nums2[mi2]))
    return (m + n) % 2 === 1 ? median1 : (median2 + median1) / 2
};

```

